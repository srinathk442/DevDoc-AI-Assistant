MenuUsing App RouterFeatures available in /appUsing Latest Version15.3.4Getting StartedInstallationProject StructureLayouts and PagesLinking and NavigatingServer and Client ComponentsPartial PrerenderingFetching DataUpdating DataCaching and RevalidatingError HandlingCSSImage OptimizationFont OptimizationMetadata and OG imagesRoute Handlers and MiddlewareDeployingUpgradingGuidesAnalyticsAuthenticationBackend for FrontendCachingCI Build CachingContent Security PolicyCSS-in-JSCustom ServerData SecurityDebuggingDraft ModeEnvironment VariablesFormsISRInstrumentationInternationalizationJSON-LDLazy LoadingDevelopment EnvironmentMDXMemory UsageMigratingApp RouterCreate React AppViteMulti-tenantMulti-zonesOpenTelemetryPackage BundlingPrefetchingProductionPWAsRedirectingSassScriptsSelf-HostingSPAsStatic ExportsTailwind CSSTestingCypressJestPlaywrightVitestThird Party LibrariesUpgradingCodemodsVersion 14Version 15VideosAPI ReferenceDirectivesuse cacheuse clientuse serverComponentsFontForm ComponentImage ComponentLink ComponentScript ComponentFile-system conventionsdefault.jsDynamic Segmentserror.jsforbidden.jsinstrumentation.jsinstrumentation-client.jsIntercepting Routeslayout.jsloading.jsmdx-components.jsmiddleware.jsnot-found.jspage.jsParallel Routespublicroute.jsRoute GroupsRoute Segment Configsrctemplate.jsunauthorized.jsMetadata Filesfavicon, icon, and apple-iconmanifest.jsonopengraph-image and twitter-imagerobots.txtsitemap.xmlFunctionsaftercacheLifecacheTagconnectioncookiesdraftModefetchforbiddengenerateImageMetadatagenerateMetadatagenerateSitemapsgenerateStaticParamsgenerateViewportheadersImageResponseNextRequestNextResponsenotFoundpermanentRedirectredirectrevalidatePathrevalidateTagunauthorizedunstable_cacheunstable_noStoreunstable_rethrowuseLinkStatususeParamsusePathnameuseReportWebVitalsuseRouteruseSearchParamsuseSelectedLayoutSegmentuseSelectedLayoutSegmentsuserAgentConfigurationnext.config.jsallowedDevOriginsappDirassetPrefixauthInterruptsbasePathcacheLifecompresscrossOrigincssChunkingdevIndicatorsdistDirdynamicIOenveslintexpireTimeexportPathMapgenerateBuildIdgenerateEtagsheadershtmlLimitedBotshttpAgentOptionsimagescacheHandlerinlineCssloggingmdxRsonDemandEntriesoptimizePackageImportsoutputpageExtensionspoweredByHeaderpprproductionBrowserSourceMapsreactCompilerreactMaxHeadersLengthreactStrictModeredirectsrewritessassOptionsserverActionsserverComponentsHmrCacheserverExternalPackagesstaleTimesstaticGeneration*tainttrailingSlashtranspilePackagesturbopacktypedRoutestypescripturlImportsuseCacheuseLightningcssviewTransitionwebpackwebVitalsAttributionTypeScriptESLintCLIcreate-next-appnext CLIEdge RuntimeTurbopackGetting StartedInstallationProject StructureImagesFontsCSSDeployingGuidesAMPAnalyticsAuthenticationBabelCI Build CachingContent Security PolicyCSS-in-JSCustom ServerDebuggingDraft ModeEnvironment VariablesFormsISRInstrumentationInternationalizationLazy LoadingMDXMigratingApp RouterCreate React AppViteMulti-ZonesOpenTelemetryPackage BundlingPostCSSPreview ModeProductionRedirectingSassScriptsSelf-HostingStatic ExportsTailwind CSSTestingCypressJestPlaywrightVitestThird Party LibrariesUpgradingCodemodsVersion 10Version 11Version 12Version 13Version 14Version 9Building Your ApplicationRoutingPages and LayoutsDynamic RoutesLinking and NavigatingCustom AppCustom DocumentAPI RoutesCustom ErrorsRenderingServer-side Rendering (SSR)Static Site Generation (SSG)Automatic Static OptimizationClient-side Rendering (CSR)Data FetchinggetStaticPropsgetStaticPathsForms and MutationsgetServerSidePropsClient-side FetchingConfiguringError HandlingAPI ReferenceComponentsFontFormHeadImageImage (Legacy)LinkScriptFile-system conventionsinstrumentation.jsMiddlewarepublicsrc DirectoryFunctionsgetInitialPropsgetServerSidePropsgetStaticPathsgetStaticPropsNextRequestNextResponseuseAmpuseReportWebVitalsuseRouteruserAgentConfigurationnext.config.js OptionsallowedDevOriginsassetPrefixbasePathbundlePagesRouterDependenciescompresscrossOrigindevIndicatorsdistDirenveslintexportPathMapgenerateBuildIdgenerateEtagsheadershttpAgentOptionsimagesonDemandEntriesoptimizePackageImportsoutputpageExtensionspoweredByHeaderproductionBrowserSourceMapsreactStrictModeredirectsrewritesRuntime ConfigserverExternalPackagestrailingSlashtranspilePackagesturbotypescripturlImportsuseLightningcsswebpackwebVitalsAttributionTypeScriptESLintCLIcreate-next-app CLInext CLIEdge RuntimeTurbopackArchitectureAccessibilityFast RefreshNext.js CompilerSupported BrowsersCommunityContribution GuideRspack{"@context":"https://schema.org","author":{"@type":"Organization","name":"Vercel"},"headline":"File-system conventions: route.js","description":"API reference for the route.js special file.","url":"https://nextjs.org/docs/app/api-reference/file-conventions/route","image":"https://nextjs.org/api/docs-og?title=File-system conventions: route.js","@type":"TechArticle"}On this pageReferenceHTTP MethodsParametersrequest (optional)context (optional)ExamplesCookiesHeadersRevalidating Cached DataRedirectsDynamic Route SegmentsURL Query ParametersStreamingRequest BodyRequest Body FormDataCORSWebhooksNon-UI ResponsesSegment Config OptionsVersion HistoryEdit this page on GitHub Scroll to top API ReferenceFile-system conventionsroute.jsroute.jsRoute Handlers allow you to create custom request handlers for a given route using the Web Request and Response APIs. route.tsTypeScriptJavaScriptTypeScriptexport async function GET() { return Response.json({ message: 'Hello World' }) } Reference HTTP Methods A route file allows you to create custom request handlers for a given route. The following HTTP methods are supported: GET, POST, PUT, PATCH, DELETE, HEAD, and OPTIONS. route.tsTypeScriptJavaScriptTypeScriptexport async function GET(request: Request) {} export async function HEAD(request: Request) {} export async function POST(request: Request) {} export async function PUT(request: Request) {} export async function DELETE(request: Request) {} export async function PATCH(request: Request) {} // If `OPTIONS` is not defined, Next.js will automatically implement `OPTIONS` and set the appropriate Response `Allow` header depending on the other methods defined in the Route Handler. export async function OPTIONS(request: Request) {} Parameters request (optional) The request object is a NextRequest object, which is an extension of the Web Request API. NextRequest gives you further control over the incoming request, including easily accessing cookies and an extended, parsed, URL object nextUrl. route.tsTypeScriptJavaScriptTypeScriptimport type { NextRequest } from 'next/server' export async function GET(request: NextRequest) { const url = request.nextUrl } context (optional) params: a promise that resolves to an object containing the dynamic route parameters for the current route. app/dashboard/[team]/route.tsTypeScriptJavaScriptTypeScriptexport async function GET( request: Request, { params }: { params: Promise<{ team: string }> } ) { const { team } = await params } ExampleURLparamsapp/dashboard/[team]/route.js/dashboard/1Promise<{ team: '1' }>app/shop/[tag]/[item]/route.js/shop/1/2Promise<{ tag: '1', item: '2' }>app/blog/[...slug]/route.js/blog/1/2Promise<{ slug: ['1', '2'] }> Examples Cookies You can read or set cookies with cookies from next/headers. route.tsTypeScriptJavaScriptTypeScriptimport { cookies } from 'next/headers' export async function GET(request: NextRequest) { const cookieStore = await cookies() const a = cookieStore.get('a') const b = cookieStore.set('b', '1') const c = cookieStore.delete('c') } Alternatively, you can return a new Response using the Set-Cookie header. app/api/route.tsTypeScriptJavaScriptTypeScriptimport { cookies } from 'next/headers' export async function GET(request: Request) { const cookieStore = await cookies() const token = cookieStore.get('token') return new Response('Hello, Next.js!', { status: 200, headers: { 'Set-Cookie': `token=${token.value}` }, }) } You can also use the underlying Web APIs to read cookies from the request (NextRequest): app/api/route.tsTypeScriptJavaScriptTypeScriptimport { type NextRequest } from 'next/server' export async function GET(request: NextRequest) { const token = request.cookies.get('token') } Headers You can read headers with headers from next/headers. route.tsTypeScriptJavaScriptTypeScriptimport { headers } from 'next/headers' import type { NextRequest } from 'next/server' export async function GET(request: NextRequest) { const headersList = await headers() const referer = headersList.get('referer') } This headers instance is read-only. To set headers, you need to return a new Response with new headers. app/api/route.tsTypeScriptJavaScriptTypeScriptimport { headers } from 'next/headers' export async function GET(request: Request) { const headersList = await headers() const referer = headersList.get('referer') return new Response('Hello, Next.js!', { status: 200, headers: { referer: referer }, }) } You can also use the underlying Web APIs to read headers from the request (NextRequest): app/api/route.tsTypeScriptJavaScriptTypeScriptimport { type NextRequest } from 'next/server' export async function GET(request: NextRequest) { const requestHeaders = new Headers(request.headers) } Revalidating Cached Data You can revalidate cached data using the revalidate route segment config option. app/posts/route.tsTypeScriptJavaScriptTypeScriptexport const revalidate = 60 export async function GET() { const data = await fetch('https://api.vercel.app/blog') const posts = await data.json() return Response.json(posts) } Redirects app/api/route.tsTypeScriptJavaScriptTypeScriptimport { redirect } from 'next/navigation' export async function GET(request: Request) { redirect('https://nextjs.org/') } Dynamic Route Segments Route Handlers can use Dynamic Segments to create request handlers from dynamic data. app/items/[slug]/route.tsTypeScriptJavaScriptTypeScriptexport async function GET( request: Request, { params }: { params: Promise<{ slug: string }> } ) { const { slug } = await params // 'a', 'b', or 'c' } RouteExample URLparamsapp/items/[slug]/route.js/items/aPromise<{ slug: 'a' }>app/items/[slug]/route.js/items/bPromise<{ slug: 'b' }>app/items/[slug]/route.js/items/cPromise<{ slug: 'c' }> URL Query Parameters The request object passed to the Route Handler is a NextRequest instance, which includes some additional convenience methods, such as those for more easily handling query parameters. app/api/search/route.tsTypeScriptJavaScriptTypeScriptimport { type NextRequest } from 'next/server' export function GET(request: NextRequest) { const searchParams = request.nextUrl.searchParams const query = searchParams.get('query') // query is "hello" for /api/search?query=hello } Streaming Streaming is commonly used in combination with Large Language Models (LLMs), such as OpenAI, for AI-generated content. Learn more about the AI SDK. app/api/chat/route.tsTypeScriptJavaScriptTypeScriptimport { openai } from '@ai-sdk/openai' import { StreamingTextResponse, streamText } from 'ai' export async function POST(req: Request) { const { messages } = await req.json() const result = await streamText({ model: openai('gpt-4-turbo'), messages, }) return new StreamingTextResponse(result.toAIStream()) } These abstractions use the Web APIs to create a stream. You can also use the underlying Web APIs directly. app/api/route.tsTypeScriptJavaScriptTypeScript// https://developer.mozilla.org/docs/Web/API/ReadableStream#convert_async_iterator_to_stream function iteratorToStream(iterator: any) { return new ReadableStream({ async pull(controller) { const { value, done } = await iterator.next() if (done) { controller.close() } else { controller.enqueue(value) } }, }) } function sleep(time: number) { return new Promise((resolve) => { setTimeout(resolve, time) }) } const encoder = new TextEncoder() async function* makeIterator() { yield encoder.encode('<p>One</p>') await sleep(200) yield encoder.encode('<p>Two</p>') await sleep(200) yield encoder.encode('<p>Three</p>') } export async function GET() { const iterator = makeIterator() const stream = iteratorToStream(iterator) return new Response(stream) } Request Body You can read the Request body using the standard Web API methods: app/items/route.tsTypeScriptJavaScriptTypeScriptexport async function POST(request: Request) { const res = await request.json() return Response.json({ res }) } Request Body FormData You can read the FormData using the request.formData() function: app/items/route.tsTypeScriptJavaScriptTypeScriptexport async function POST(request: Request) { const formData = await request.formData() const name = formData.get('name') const email = formData.get('email') return Response.json({ name, email }) } Since formData data are all strings, you may want to use zod-form-data to validate the request and retrieve data in the format you prefer (e.g. number). CORS You can set CORS headers for a specific Route Handler using the standard Web API methods: app/api/route.tsTypeScriptJavaScriptTypeScriptexport async function GET(request: Request) { return new Response('Hello, Next.js!', { status: 200, headers: { 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS', 'Access-Control-Allow-Headers': 'Content-Type, Authorization', }, }) } Good to know: To add CORS headers to multiple Route Handlers, you can use Middleware or the next.config.js file. Alternatively, see our CORS example package. Webhooks You can use a Route Handler to receive webhooks from third-party services: app/api/route.tsTypeScriptJavaScriptTypeScriptexport async function POST(request: Request) { try { const text = await request.text() // Process the webhook payload } catch (error) { return new Response(`Webhook error: ${error.message}`, { status: 400, }) } return new Response('Success!', { status: 200, }) } Notably, unlike API Routes with the Pages Router, you do not need to use bodyParser to use any additional configuration. Non-UI Responses You can use Route Handlers to return non-UI content. Note that sitemap.xml, robots.txt, app icons, and open graph images all have built-in support. app/rss.xml/route.tsTypeScriptJavaScriptTypeScriptexport async function GET() { return new Response( `<?xml version="1.0" encoding="UTF-8" ?> <rss version="2.0"> <channel> <title>Next.js Documentation</title> <link>https://nextjs.org/docs</link> <description>The React Framework for the Web</description> </channel> </rss>`, { headers: { 'Content-Type': 'text/xml', }, } ) } Segment Config Options Route Handlers use the same route segment configuration as pages and layouts. app/items/route.tsTypeScriptJavaScriptTypeScriptexport const dynamic = 'auto' export const dynamicParams = true export const revalidate = false export const fetchCache = 'auto' export const runtime = 'nodejs' export const preferredRegion = 'auto' See the API reference for more details. Version History VersionChangesv15.0.0-RCcontext.params is now a promise. A codemod is availablev15.0.0-RCThe default caching for GET handlers was changed from static to dynamicv13.2.0Route Handlers are introduced.PreviouspublicNextRoute GroupsWas this helpful? supported.Send