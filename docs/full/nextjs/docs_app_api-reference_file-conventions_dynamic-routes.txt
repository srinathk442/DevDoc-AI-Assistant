MenuUsing App RouterFeatures available in /appUsing Latest Version15.3.4Getting StartedInstallationProject StructureLayouts and PagesLinking and NavigatingServer and Client ComponentsPartial PrerenderingFetching DataUpdating DataCaching and RevalidatingError HandlingCSSImage OptimizationFont OptimizationMetadata and OG imagesRoute Handlers and MiddlewareDeployingUpgradingGuidesAnalyticsAuthenticationBackend for FrontendCachingCI Build CachingContent Security PolicyCSS-in-JSCustom ServerData SecurityDebuggingDraft ModeEnvironment VariablesFormsISRInstrumentationInternationalizationJSON-LDLazy LoadingDevelopment EnvironmentMDXMemory UsageMigratingApp RouterCreate React AppViteMulti-tenantMulti-zonesOpenTelemetryPackage BundlingPrefetchingProductionPWAsRedirectingSassScriptsSelf-HostingSPAsStatic ExportsTailwind CSSTestingCypressJestPlaywrightVitestThird Party LibrariesUpgradingCodemodsVersion 14Version 15VideosAPI ReferenceDirectivesuse cacheuse clientuse serverComponentsFontForm ComponentImage ComponentLink ComponentScript ComponentFile-system conventionsdefault.jsDynamic Segmentserror.jsforbidden.jsinstrumentation.jsinstrumentation-client.jsIntercepting Routeslayout.jsloading.jsmdx-components.jsmiddleware.jsnot-found.jspage.jsParallel Routespublicroute.jsRoute GroupsRoute Segment Configsrctemplate.jsunauthorized.jsMetadata Filesfavicon, icon, and apple-iconmanifest.jsonopengraph-image and twitter-imagerobots.txtsitemap.xmlFunctionsaftercacheLifecacheTagconnectioncookiesdraftModefetchforbiddengenerateImageMetadatagenerateMetadatagenerateSitemapsgenerateStaticParamsgenerateViewportheadersImageResponseNextRequestNextResponsenotFoundpermanentRedirectredirectrevalidatePathrevalidateTagunauthorizedunstable_cacheunstable_noStoreunstable_rethrowuseLinkStatususeParamsusePathnameuseReportWebVitalsuseRouteruseSearchParamsuseSelectedLayoutSegmentuseSelectedLayoutSegmentsuserAgentConfigurationnext.config.jsallowedDevOriginsappDirassetPrefixauthInterruptsbasePathcacheLifecompresscrossOrigincssChunkingdevIndicatorsdistDirdynamicIOenveslintexpireTimeexportPathMapgenerateBuildIdgenerateEtagsheadershtmlLimitedBotshttpAgentOptionsimagescacheHandlerinlineCssloggingmdxRsonDemandEntriesoptimizePackageImportsoutputpageExtensionspoweredByHeaderpprproductionBrowserSourceMapsreactCompilerreactMaxHeadersLengthreactStrictModeredirectsrewritessassOptionsserverActionsserverComponentsHmrCacheserverExternalPackagesstaleTimesstaticGeneration*tainttrailingSlashtranspilePackagesturbopacktypedRoutestypescripturlImportsuseCacheuseLightningcssviewTransitionwebpackwebVitalsAttributionTypeScriptESLintCLIcreate-next-appnext CLIEdge RuntimeTurbopackGetting StartedInstallationProject StructureImagesFontsCSSDeployingGuidesAMPAnalyticsAuthenticationBabelCI Build CachingContent Security PolicyCSS-in-JSCustom ServerDebuggingDraft ModeEnvironment VariablesFormsISRInstrumentationInternationalizationLazy LoadingMDXMigratingApp RouterCreate React AppViteMulti-ZonesOpenTelemetryPackage BundlingPostCSSPreview ModeProductionRedirectingSassScriptsSelf-HostingStatic ExportsTailwind CSSTestingCypressJestPlaywrightVitestThird Party LibrariesUpgradingCodemodsVersion 10Version 11Version 12Version 13Version 14Version 9Building Your ApplicationRoutingPages and LayoutsDynamic RoutesLinking and NavigatingCustom AppCustom DocumentAPI RoutesCustom ErrorsRenderingServer-side Rendering (SSR)Static Site Generation (SSG)Automatic Static OptimizationClient-side Rendering (CSR)Data FetchinggetStaticPropsgetStaticPathsForms and MutationsgetServerSidePropsClient-side FetchingConfiguringError HandlingAPI ReferenceComponentsFontFormHeadImageImage (Legacy)LinkScriptFile-system conventionsinstrumentation.jsMiddlewarepublicsrc DirectoryFunctionsgetInitialPropsgetServerSidePropsgetStaticPathsgetStaticPropsNextRequestNextResponseuseAmpuseReportWebVitalsuseRouteruserAgentConfigurationnext.config.js OptionsallowedDevOriginsassetPrefixbasePathbundlePagesRouterDependenciescompresscrossOrigindevIndicatorsdistDirenveslintexportPathMapgenerateBuildIdgenerateEtagsheadershttpAgentOptionsimagesonDemandEntriesoptimizePackageImportsoutputpageExtensionspoweredByHeaderproductionBrowserSourceMapsreactStrictModeredirectsrewritesRuntime ConfigserverExternalPackagestrailingSlashtranspilePackagesturbotypescripturlImportsuseLightningcsswebpackwebVitalsAttributionTypeScriptESLintCLIcreate-next-app CLInext CLIEdge RuntimeTurbopackArchitectureAccessibilityFast RefreshNext.js CompilerSupported BrowsersCommunityContribution GuideRspack{"@context":"https://schema.org","author":{"@type":"Organization","name":"Vercel"},"headline":"File-system conventions: Dynamic Segments","description":"Dynamic Route Segments can be used to programmatically generate route segments from dynamic data.","url":"https://nextjs.org/docs/app/api-reference/file-conventions/dynamic-routes","image":"https://nextjs.org/api/docs-og?title=File-system conventions: Dynamic Segments","@type":"TechArticle"}On this pageConventionCatch-all SegmentsOptional Catch-all SegmentsTypeScriptBehaviorExamplesWith generateStaticParamsNext StepsEdit this page on GitHub Scroll to top API ReferenceFile-system conventionsDynamic SegmentsDynamic Route SegmentsWhen you don't know the exact route segment names ahead of time and want to create routes from dynamic data, you can use Dynamic Segments that are filled in at request time or prerendered at build time. Convention A Dynamic Segment can be created by wrapping a folder's name in square brackets: [folderName]. For example, a blog could include the following route app/blog/[slug]/page.js where [slug] is the Dynamic Segment for blog posts. app/blog/[slug]/page.tsxTypeScriptJavaScriptTypeScriptexport default async function Page({ params, }: { params: Promise<{ slug: string }> }) { const { slug } = await params return <div>My Post: {slug}</div> } Dynamic Segments are passed as the params prop to layout, page, route, and generateMetadata functions. RouteExample URLparamsapp/blog/[slug]/page.js/blog/a{ slug: 'a' }app/blog/[slug]/page.js/blog/b{ slug: 'b' }app/blog/[slug]/page.js/blog/c{ slug: 'c' } Catch-all Segments Dynamic Segments can be extended to catch-all subsequent segments by adding an ellipsis inside the brackets [...folderName]. For example, app/shop/[...slug]/page.js will match /shop/clothes, but also /shop/clothes/tops, /shop/clothes/tops/t-shirts, and so on. RouteExample URLparamsapp/shop/[...slug]/page.js/shop/a{ slug: ['a'] }app/shop/[...slug]/page.js/shop/a/b{ slug: ['a', 'b'] }app/shop/[...slug]/page.js/shop/a/b/c{ slug: ['a', 'b', 'c'] } Optional Catch-all Segments Catch-all Segments can be made optional by including the parameter in double square brackets: [[...folderName]]. For example, app/shop/[[...slug]]/page.js will also match /shop, in addition to /shop/clothes, /shop/clothes/tops, /shop/clothes/tops/t-shirts. The difference between catch-all and optional catch-all segments is that with optional, the route without the parameter is also matched (/shop in the example above). RouteExample URLparamsapp/shop/[[...slug]]/page.js/shop{ slug: undefined }app/shop/[[...slug]]/page.js/shop/a{ slug: ['a'] }app/shop/[[...slug]]/page.js/shop/a/b{ slug: ['a', 'b'] }app/shop/[[...slug]]/page.js/shop/a/b/c{ slug: ['a', 'b', 'c'] } TypeScript When using TypeScript, you can add types for params depending on your configured route segment. Routeparams Type Definitionapp/blog/[slug]/page.js{ slug: string }app/shop/[...slug]/page.js{ slug: string[] }app/shop/[[...slug]]/page.js{ slug?: string[] }app/[categoryId]/[itemId]/page.js{ categoryId: string, itemId: string } Behavior Since the params prop is a promise. You must use async/await or React's use function to access the values. In version 14 and earlier, params was a synchronous prop. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future. Examples With generateStaticParams The generateStaticParams function can be used to statically generate routes at build time instead of on-demand at request time. app/blog/[slug]/page.tsxTypeScriptJavaScriptTypeScriptexport async function generateStaticParams() { const posts = await fetch('https://.../posts').then((res) => res.json()) return posts.map((post) => ({ slug: post.slug, })) } When using fetch inside the generateStaticParams function, the requests are automatically deduplicated. This avoids multiple network calls for the same data Layouts, Pages, and other generateStaticParams functions, speeding up build time.Next StepsFor more information on what to do next, we recommend the following sectionsgenerateStaticParamsAPI reference for the generateStaticParams function.Previousdefault.jsNexterror.jsWas this helpful? supported.Send