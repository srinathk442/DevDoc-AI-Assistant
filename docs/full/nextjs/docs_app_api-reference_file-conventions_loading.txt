MenuUsing App RouterFeatures available in /appUsing Latest Version15.3.4Getting StartedInstallationProject StructureLayouts and PagesLinking and NavigatingServer and Client ComponentsPartial PrerenderingFetching DataUpdating DataCaching and RevalidatingError HandlingCSSImage OptimizationFont OptimizationMetadata and OG imagesRoute Handlers and MiddlewareDeployingUpgradingGuidesAnalyticsAuthenticationBackend for FrontendCachingCI Build CachingContent Security PolicyCSS-in-JSCustom ServerData SecurityDebuggingDraft ModeEnvironment VariablesFormsISRInstrumentationInternationalizationJSON-LDLazy LoadingDevelopment EnvironmentMDXMemory UsageMigratingApp RouterCreate React AppViteMulti-tenantMulti-zonesOpenTelemetryPackage BundlingPrefetchingProductionPWAsRedirectingSassScriptsSelf-HostingSPAsStatic ExportsTailwind CSSTestingCypressJestPlaywrightVitestThird Party LibrariesUpgradingCodemodsVersion 14Version 15VideosAPI ReferenceDirectivesuse cacheuse clientuse serverComponentsFontForm ComponentImage ComponentLink ComponentScript ComponentFile-system conventionsdefault.jsDynamic Segmentserror.jsforbidden.jsinstrumentation.jsinstrumentation-client.jsIntercepting Routeslayout.jsloading.jsmdx-components.jsmiddleware.jsnot-found.jspage.jsParallel Routespublicroute.jsRoute GroupsRoute Segment Configsrctemplate.jsunauthorized.jsMetadata Filesfavicon, icon, and apple-iconmanifest.jsonopengraph-image and twitter-imagerobots.txtsitemap.xmlFunctionsaftercacheLifecacheTagconnectioncookiesdraftModefetchforbiddengenerateImageMetadatagenerateMetadatagenerateSitemapsgenerateStaticParamsgenerateViewportheadersImageResponseNextRequestNextResponsenotFoundpermanentRedirectredirectrevalidatePathrevalidateTagunauthorizedunstable_cacheunstable_noStoreunstable_rethrowuseLinkStatususeParamsusePathnameuseReportWebVitalsuseRouteruseSearchParamsuseSelectedLayoutSegmentuseSelectedLayoutSegmentsuserAgentConfigurationnext.config.jsallowedDevOriginsappDirassetPrefixauthInterruptsbasePathcacheLifecompresscrossOrigincssChunkingdevIndicatorsdistDirdynamicIOenveslintexpireTimeexportPathMapgenerateBuildIdgenerateEtagsheadershtmlLimitedBotshttpAgentOptionsimagescacheHandlerinlineCssloggingmdxRsonDemandEntriesoptimizePackageImportsoutputpageExtensionspoweredByHeaderpprproductionBrowserSourceMapsreactCompilerreactMaxHeadersLengthreactStrictModeredirectsrewritessassOptionsserverActionsserverComponentsHmrCacheserverExternalPackagesstaleTimesstaticGeneration*tainttrailingSlashtranspilePackagesturbopacktypedRoutestypescripturlImportsuseCacheuseLightningcssviewTransitionwebpackwebVitalsAttributionTypeScriptESLintCLIcreate-next-appnext CLIEdge RuntimeTurbopackGetting StartedInstallationProject StructureImagesFontsCSSDeployingGuidesAMPAnalyticsAuthenticationBabelCI Build CachingContent Security PolicyCSS-in-JSCustom ServerDebuggingDraft ModeEnvironment VariablesFormsISRInstrumentationInternationalizationLazy LoadingMDXMigratingApp RouterCreate React AppViteMulti-ZonesOpenTelemetryPackage BundlingPostCSSPreview ModeProductionRedirectingSassScriptsSelf-HostingStatic ExportsTailwind CSSTestingCypressJestPlaywrightVitestThird Party LibrariesUpgradingCodemodsVersion 10Version 11Version 12Version 13Version 14Version 9Building Your ApplicationRoutingPages and LayoutsDynamic RoutesLinking and NavigatingCustom AppCustom DocumentAPI RoutesCustom ErrorsRenderingServer-side Rendering (SSR)Static Site Generation (SSG)Automatic Static OptimizationClient-side Rendering (CSR)Data FetchinggetStaticPropsgetStaticPathsForms and MutationsgetServerSidePropsClient-side FetchingConfiguringError HandlingAPI ReferenceComponentsFontFormHeadImageImage (Legacy)LinkScriptFile-system conventionsinstrumentation.jsMiddlewarepublicsrc DirectoryFunctionsgetInitialPropsgetServerSidePropsgetStaticPathsgetStaticPropsNextRequestNextResponseuseAmpuseReportWebVitalsuseRouteruserAgentConfigurationnext.config.js OptionsallowedDevOriginsassetPrefixbasePathbundlePagesRouterDependenciescompresscrossOrigindevIndicatorsdistDirenveslintexportPathMapgenerateBuildIdgenerateEtagsheadershttpAgentOptionsimagesonDemandEntriesoptimizePackageImportsoutputpageExtensionspoweredByHeaderproductionBrowserSourceMapsreactStrictModeredirectsrewritesRuntime ConfigserverExternalPackagestrailingSlashtranspilePackagesturbotypescripturlImportsuseLightningcsswebpackwebVitalsAttributionTypeScriptESLintCLIcreate-next-app CLInext CLIEdge RuntimeTurbopackArchitectureAccessibilityFast RefreshNext.js CompilerSupported BrowsersCommunityContribution GuideRspack{"@context":"https://schema.org","author":{"@type":"Organization","name":"Vercel"},"headline":"File-system conventions: loading.js","description":"API reference for the loading.js file.","url":"https://nextjs.org/docs/app/api-reference/file-conventions/loading","image":"https://nextjs.org/api/docs-og?title=File-system conventions: loading.js","@type":"TechArticle"}On this pageReferenceParametersBehaviorNavigationInstant Loading StatesSEOStatus CodesBrowser limitsPlatform SupportExamplesStreaming with SuspenseVersion HistoryEdit this page on GitHub Scroll to top API ReferenceFile-system conventionsloading.jsloading.jsThe special file loading.js helps you create meaningful Loading UI with React Suspense. With this convention, you can show an instant loading state from the server while the content of a route segment streams in. The new content is automatically swapped in once complete. app/feed/loading.tsxTypeScriptJavaScriptTypeScriptexport default function Loading() { // Or a custom loading skeleton component return <p>Loading...</p> } Inside the loading.js file, you can add any light-weight loading UI. You may find it helpful to use the React Developer Tools to manually toggle Suspense boundaries. By default, this file is a Server Component - but can also be used as a Client Component through the "use client" directive. Reference Parameters Loading UI components do not accept any parameters. Behavior Navigation The Fallback UI is prefetched, making navigation is immediate unless prefetching hasn't completed. Navigation is interruptible, meaning changing routes does not need to wait for the content of the route to fully load before navigating to another route. Shared layouts remain interactive while new route segments load. Instant Loading States An instant loading state is fallback UI that is shown immediately upon navigation. You can pre-render loading indicators such as skeletons and spinners, or a small but meaningful part of future screens such as a cover photo, title, etc. This helps users understand the app is responding and provides a better user experience. Create a loading state by adding a loading.js file inside a folder. app/dashboard/loading.tsxTypeScriptJavaScriptTypeScriptexport default function Loading() { // You can add any UI inside Loading, including a Skeleton. return <LoadingSkeleton /> } In the same folder, loading.js will be nested inside layout.js. It will automatically wrap the page.js file and any children below in a <Suspense> boundary. SEO Next.js will wait for data fetching inside generateMetadata to complete before streaming UI to the client. This guarantees the first part of a streamed response includes <head> tags. Since streaming is server-rendered, it does not impact SEO. You can use the Rich Results Test tool from Google to see how your page appears to Google's web crawlers and view the serialized HTML (source). Status Codes When streaming, a 200 status code will be returned to signal that the request was successful. The server can still communicate errors or issues to the client within the streamed content itself, for example, when using redirect or notFound. Since the response headers have already been sent to the client, the status code of the response cannot be updated. This does not affect SEO. Browser limits Some browsers buffer a streaming response. You may not see the streamed response until the response exceeds 1024 bytes. This typically only affects “hello world” applications, but not real applications. Platform Support Deployment OptionSupportedNode.js serverYesDocker containerYesStatic exportNoAdaptersPlatform-specific Learn how to configure streaming when self-hosting Next.js. Examples Streaming with Suspense In addition to loading.js, you can also manually create Suspense Boundaries for your own UI components. The App Router supports streaming with Suspense. <Suspense> works by wrapping a component that performs an asynchronous action (e.g. fetch data), showing fallback UI (e.g. skeleton, spinner) while it's happening, and then swapping in your component once the action completes. app/dashboard/page.tsxTypeScriptJavaScriptTypeScriptimport { Suspense } from 'react' import { PostFeed, Weather } from './Components' export default function Posts() { return ( <section> <Suspense fallback={<p>Loading feed...</p>}> <PostFeed /> </Suspense> <Suspense fallback={<p>Loading weather...</p>}> <Weather /> </Suspense> </section> ) } By using Suspense, you get the benefits of: Streaming Server Rendering - Progressively rendering HTML from the server to the client. Selective Hydration - React prioritizes what components to make interactive first based on user interaction. For more Suspense examples and use cases, please see the React Documentation. Version History VersionChangesv13.0.0loading introduced.Previouslayout.jsNextmdx-components.jsWas this helpful? supported.Send