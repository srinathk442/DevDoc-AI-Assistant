MenuUsing App RouterFeatures available in /appUsing Latest Version15.3.4Getting StartedInstallationProject StructureLayouts and PagesLinking and NavigatingServer and Client ComponentsPartial PrerenderingFetching DataUpdating DataCaching and RevalidatingError HandlingCSSImage OptimizationFont OptimizationMetadata and OG imagesRoute Handlers and MiddlewareDeployingUpgradingGuidesAnalyticsAuthenticationBackend for FrontendCachingCI Build CachingContent Security PolicyCSS-in-JSCustom ServerData SecurityDebuggingDraft ModeEnvironment VariablesFormsISRInstrumentationInternationalizationJSON-LDLazy LoadingDevelopment EnvironmentMDXMemory UsageMigratingApp RouterCreate React AppViteMulti-tenantMulti-zonesOpenTelemetryPackage BundlingPrefetchingProductionPWAsRedirectingSassScriptsSelf-HostingSPAsStatic ExportsTailwind CSSTestingCypressJestPlaywrightVitestThird Party LibrariesUpgradingCodemodsVersion 14Version 15VideosAPI ReferenceDirectivesuse cacheuse clientuse serverComponentsFontForm ComponentImage ComponentLink ComponentScript ComponentFile-system conventionsdefault.jsDynamic Segmentserror.jsforbidden.jsinstrumentation.jsinstrumentation-client.jsIntercepting Routeslayout.jsloading.jsmdx-components.jsmiddleware.jsnot-found.jspage.jsParallel Routespublicroute.jsRoute GroupsRoute Segment Configsrctemplate.jsunauthorized.jsMetadata Filesfavicon, icon, and apple-iconmanifest.jsonopengraph-image and twitter-imagerobots.txtsitemap.xmlFunctionsaftercacheLifecacheTagconnectioncookiesdraftModefetchforbiddengenerateImageMetadatagenerateMetadatagenerateSitemapsgenerateStaticParamsgenerateViewportheadersImageResponseNextRequestNextResponsenotFoundpermanentRedirectredirectrevalidatePathrevalidateTagunauthorizedunstable_cacheunstable_noStoreunstable_rethrowuseLinkStatususeParamsusePathnameuseReportWebVitalsuseRouteruseSearchParamsuseSelectedLayoutSegmentuseSelectedLayoutSegmentsuserAgentConfigurationnext.config.jsallowedDevOriginsappDirassetPrefixauthInterruptsbasePathcacheLifecompresscrossOrigincssChunkingdevIndicatorsdistDirdynamicIOenveslintexpireTimeexportPathMapgenerateBuildIdgenerateEtagsheadershtmlLimitedBotshttpAgentOptionsimagescacheHandlerinlineCssloggingmdxRsonDemandEntriesoptimizePackageImportsoutputpageExtensionspoweredByHeaderpprproductionBrowserSourceMapsreactCompilerreactMaxHeadersLengthreactStrictModeredirectsrewritessassOptionsserverActionsserverComponentsHmrCacheserverExternalPackagesstaleTimesstaticGeneration*tainttrailingSlashtranspilePackagesturbopacktypedRoutestypescripturlImportsuseCacheuseLightningcssviewTransitionwebpackwebVitalsAttributionTypeScriptESLintCLIcreate-next-appnext CLIEdge RuntimeTurbopackGetting StartedInstallationProject StructureImagesFontsCSSDeployingGuidesAMPAnalyticsAuthenticationBabelCI Build CachingContent Security PolicyCSS-in-JSCustom ServerDebuggingDraft ModeEnvironment VariablesFormsISRInstrumentationInternationalizationLazy LoadingMDXMigratingApp RouterCreate React AppViteMulti-ZonesOpenTelemetryPackage BundlingPostCSSPreview ModeProductionRedirectingSassScriptsSelf-HostingStatic ExportsTailwind CSSTestingCypressJestPlaywrightVitestThird Party LibrariesUpgradingCodemodsVersion 10Version 11Version 12Version 13Version 14Version 9Building Your ApplicationRoutingPages and LayoutsDynamic RoutesLinking and NavigatingCustom AppCustom DocumentAPI RoutesCustom ErrorsRenderingServer-side Rendering (SSR)Static Site Generation (SSG)Automatic Static OptimizationClient-side Rendering (CSR)Data FetchinggetStaticPropsgetStaticPathsForms and MutationsgetServerSidePropsClient-side FetchingConfiguringError HandlingAPI ReferenceComponentsFontFormHeadImageImage (Legacy)LinkScriptFile-system conventionsinstrumentation.jsMiddlewarepublicsrc DirectoryFunctionsgetInitialPropsgetServerSidePropsgetStaticPathsgetStaticPropsNextRequestNextResponseuseAmpuseReportWebVitalsuseRouteruserAgentConfigurationnext.config.js OptionsallowedDevOriginsassetPrefixbasePathbundlePagesRouterDependenciescompresscrossOrigindevIndicatorsdistDirenveslintexportPathMapgenerateBuildIdgenerateEtagsheadershttpAgentOptionsimagesonDemandEntriesoptimizePackageImportsoutputpageExtensionspoweredByHeaderproductionBrowserSourceMapsreactStrictModeredirectsrewritesRuntime ConfigserverExternalPackagestrailingSlashtranspilePackagesturbotypescripturlImportsuseLightningcsswebpackwebVitalsAttributionTypeScriptESLintCLIcreate-next-app CLInext CLIEdge RuntimeTurbopackArchitectureAccessibilityFast RefreshNext.js CompilerSupported BrowsersCommunityContribution GuideRspack{"@context":"https://schema.org","author":{"@type":"Organization","name":"Vercel"},"headline":"Guides: Prefetching","description":"Learn how to configure prefetching in Next.js","url":"https://nextjs.org/docs/app/guides/prefetching","image":"https://nextjs.org/api/docs-og?title=Guides: Prefetching","@type":"TechArticle"}On this pageHow does prefetching work?Prefetching static vs. dynamic routesAutomatic prefetchManual prefetchHover-triggered prefetchExtending or ejecting linkDisabled prefetchPrefetching optimizationsClient cachePrefetch schedulingPartial Prerendering (PPR)TroubleshootingTriggering unwanted side-effects during prefetchingPreventing too many prefetchesEdit this page on GitHub Scroll to top App RouterGuidesPrefetchingPrefetchingPrefetching makes navigating between different routes in your application feel instant. Next.js tries to intelligently prefetch by default, based on the links used in your application code. This guide will explain how prefetching works and show common implementation patterns: Automatic prefetch Manual prefetch Hover-triggered prefetch Extending or ejecting link Disabled prefetch How does prefetching work? When navigating between routes, the browser requests assets for the page like HTML and JavaScript files. Prefetching is the process of fetching these resources ahead of time, before you navigate to a new route. Next.js automatically splits your application into smaller JavaScript chunks based on routes. Instead of loading all the code upfront like traditional SPAs, only the code needed for the current route is loaded. This reduces the initial load time while other parts of the app are loaded in the background. By the time you click the link, the resources for the new route have already been loaded into the browser cache. When navigating to the new page, there's no full page reload or browser loading spinner. Instead, Next.js performs a client-side transition, making the page navigation feel instant. Prefetching static vs. dynamic routes Static pageDynamic pagePrefetchedYes, full routeNo, unless loading.jsClient Cache TTL5 min (default)Off, unless enabledServer roundtrip on clickNoYes, streamed after shell Good to know: During the initial navigation, the browser fetches the HTML, JavaScript, and React Server Components (RSC) Payload. For subsequent navigations, the browser will fetch the RSC Payload for Server Components and JS bundle for Client Components. Automatic prefetch app/ui/nav-link.tsxTypeScriptJavaScriptTypeScriptimport Link from 'next/link' export default function NavLink() { return <Link href="/about">About</Link> } ContextPrefetched payloadClient Cache TTLNo loading.jsEntire pageUntil app reloadWith loading.jsLayout to first loading boundary30s (configurable) Automatic prefetching runs only in production. Disable with prefetch={false} or use the wrapper in Disabled Prefetch. Manual prefetch 'use client' import { useRouter } from 'next/navigation' const router = useRouter() router.prefetch('/pricing') Call router.prefetch() to warm routes outside the viewport or in response to analytics, hover, scroll, etc. Hover-triggered prefetch Proceed with caution: Extending Link opts you into maintaining prefetching, cache invalidation, and accessibility concerns. Proceed only if defaults are insufficient. Next.js tries to do the right prefetching by default, but power users can eject and modify based on their needs. You have the control between performance and resource consumption. For example, you might have to only trigger prefetches on hover, instead of when entering the viewport (the default behavior): 'use client' import Link from 'next/link' import { useState } from 'react' export function HoverPrefetchLink({ href, children, }: { href: string children: React.ReactNode }) { const [active, setActive] = useState(false) return ( <Link href={href} prefetch={active ? null : false} onMouseEnter={() => setActive(true)} > {children} </Link> ) } prefetch={null} restores default (static) prefetching once the user shows intent. Extending or ejecting link You can extend the <Link> component to create your own custom prefetching strategy. For example, using the ForesightJS library which prefetches links by predicting the direction of the user's cursor. Alternatively, you can use useRouter to recreate some of the native <Link> behavior. However, be aware this opts you into maintaining prefetching and cache invalidation. 'use client' import { useRouter } from 'next/navigation' import { useEffect } from 'react' function ManualPrefetchLink({ href, children, }: { href: string children: React.ReactNode }) { const router = useRouter() useEffect(() => { let cancelled = false const poll = () => { if (!cancelled) router.prefetch(href, { onInvalidate: poll }) } poll() return () => { cancelled = true } }, [href, router]) return ( <a href={href} onClick={(event) => { event.preventDefault() router.push(href) }} > {children} </a> ) } onInvalidate is invoked when Next.js suspects cached data is stale, allowing you to refresh the prefetch. Good to know: Using an a tag will cause a full page navigation to the destination route, you can use onClick to prevent the full page navigation, and then invoke router.push to navigate to the destination. Disabled prefetch You can fully disable prefetching for certain routes for more fine-grained control over resource consumption. 'use client' import Link, { LinkProps } from 'next/link' function NoPrefetchLink({ prefetch, ...rest }: LinkProps & { children: React.ReactNode }) { return <Link {...rest} prefetch={false} /> } For example, you may still want to have consistent usage of <Link> in your application, but links in your footer might not need to be prefetched when entering the viewport. Prefetching optimizations Good to know: Layout deduplication and prefetch scheduling are part of upcoming optimizations. Currently available in Next.js canary via the experimental.clientSegmentCache flag. Client cache Next.js stores prefetched React Server Component payloads in memory, keyed by route segments. When navigating between sibling routes (e.g. /dashboard/settings → /dashboard/analytics), it reuses the parent layout and only fetches the updated leaf page. This reduces network traffic and improves navigation speed. Prefetch scheduling Next.js maintains a small task queue, which prefetches in the following order: Links in the viewport Links showing user intent (hover or touch) Newer links replace older ones Links scrolled off-screen are discarded The scheduler prioritizes likely navigations while minimizing unused downloads. Partial Prerendering (PPR) When PPR is enabled, a page is divided into a static shell and a streamed dynamic section: The shell, which can be prefetched, streams immediately Dynamic data streams when ready Data invalidations (revalidateTag, revalidatePath) silently refresh associated prefetches Troubleshooting Triggering unwanted side-effects during prefetching If your layouts or pages are not pure and have side-effects (e.g. tracking analytics), these might be triggered when the route is prefetched, not when the user visits the page. To avoid this, you should move side-effects to a useEffect hook or a Server Action triggered from a Client Component. Before: app/dashboard/layout.tsxTypeScriptJavaScriptTypeScriptimport { trackPageView } from '@/lib/analytics' export default function Layout({ children }: { children: React.ReactNode }) { // This runs during prefetch trackPageView() return <div>{children}</div> } After: app/ui/analytics-tracker.tsxTypeScriptJavaScriptTypeScript'use client' import { useEffect } from 'react' import { trackPageView } from '@/lib/analytics' export function AnalyticsTracker() { useEffect(() => { trackPageView() }, []) return null } app/dashboard/layout.tsxTypeScriptJavaScriptTypeScriptimport { AnalyticsTracker } from '@/app/ui/analytics-tracker' export default function Layout({ children }: { children: React.ReactNode }) { return ( <div> <AnalyticsTracker /> {children} </div> ) } Preventing too many prefetches Next.js automatically prefetches links in the viewport when using the <Link> component. There may be cases where you want to prevent this to avoid unnecessary usage of resources, such as when rendering a large list of links (e.g. an infinite scroll table). You can disable prefetching by setting the prefetch prop of the <Link> component to false. app/ui/no-prefetch-link.tsxTypeScriptJavaScriptTypeScript<Link prefetch={false} href={`/blog/${post.id}`}> {post.title} </Link> However, this means static routes will only be fetched on click, and dynamic routes will wait for the server to render before navigating. To reduce resource usage without disabling prefetch entirely, you can defer prefetching until the user hovers over a link. This targets only links the user is likely to visit. app/ui/hover-prefetch-link.tsxTypeScriptJavaScriptTypeScript'use client' import Link from 'next/link' import { useState } from 'react' export function HoverPrefetchLink({ href, children, }: { href: string children: React.ReactNode }) { const [active, setActive] = useState(false) return ( <Link href={href} prefetch={active ? null : false} onMouseEnter={() => setActive(true)} > {children} </Link> ) } PreviousPackage BundlingNextProductionWas this helpful? supported.Send