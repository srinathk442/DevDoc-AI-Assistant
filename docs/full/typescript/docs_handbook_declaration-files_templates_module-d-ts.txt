Comparing JavaScript to an example DTS Common CommonJS Patterns A module using CommonJS patterns uses module.exports to describe the exported values. For example, here is a module which exports a function and a numerical constant: jsconst maxInterval = 12;function getArrayLength(arr) { return arr.length;}module.exports = { getArrayLength, maxInterval,}; This can be described by the following .d.ts: tsexport function getArrayLength(arr: any[]): number;export const maxInterval: 12; The TypeScript playground can show you the .d.ts equivalent for JavaScript code. You can try it yourself here. The .d.ts syntax intentionally looks like ES Modules syntax. ES Modules was ratified by TC39 in 2015 as part of ES2015 (ES6), while it has been available via transpilers for a long time, however if you have a JavaScript codebase using ES Modules: jsexport function getArrayLength(arr) { return arr.length;} This would have the following .d.ts equivalent: tsexport function getArrayLength(arr: any[]): number; Default Exports In CommonJS you can export any value as the default export, for example here is a regular expression module: jsmodule.exports = /hello( world)?/; Which can be described by the following .d.ts: tsdeclare const helloWorld: RegExp;export = helloWorld; Or a number: jsmodule.exports = 3.142; tsdeclare const pi: number;export = pi; One style of exporting in CommonJS is to export a function. Because a function is also an object, then extra fields can be added and are included in the export. jsfunction getArrayLength(arr) { return arr.length;}getArrayLength.maxInterval = 12;module.exports = getArrayLength; Which can be described with: tsdeclare function getArrayLength(arr: any[]): number;declare namespace getArrayLength { declare const maxInterval: 12;}export = getArrayLength; See Module: Functions for details of how that works, and the Modules reference page. Handling Many Consuming Import There are many ways to import a module in modern consuming code: tsconst fastify = require("fastify");const { fastify } = require("fastify");import fastify = require("fastify");import * as Fastify from "fastify";import { fastify, FastifyInstance } from "fastify";import fastify from "fastify";import fastify, { FastifyInstance } from "fastify"; Covering all of these cases requires the JavaScript code to actually support all of these patterns. To support many of these patterns, a CommonJS module would need to look something like: jsclass FastifyInstance {}function fastify() { return new FastifyInstance();}fastify.FastifyInstance = FastifyInstance;// Allows for { fastify }fastify.fastify = fastify;// Allows for strict ES Module supportfastify.default = fastify;// Sets the default exportmodule.exports = fastify; Types in Modules You may want to provide a type for JavaScript code which does not exist jsfunction getArrayMetadata(arr) { return { length: getArrayLength(arr), firstObject: arr[0], };}module.exports = { getArrayMetadata,}; This can be described with: tsexport type ArrayMetadata = { length: number; firstObject: any | undefined;};export function getArrayMetadata(arr: any[]): ArrayMetadata; This example is a good case for using generics to provide richer type information: tsexport type ArrayMetadata<ArrType> = { length: number; firstObject: ArrType | undefined;};export function getArrayMetadata<ArrType>( arr: ArrType[]): ArrayMetadata<ArrType>; Now the type of the array propagates into the ArrayMetadata type. The types which are exported can then be re-used by consumers of the modules using either import or import type in TypeScript code or JSDoc imports. Namespaces in Module Code Trying to describe the runtime relationship of JavaScript code can be tricky. When the ES Module-like syntax doesn’t provide enough tools to describe the exports then you can use namespaces. For example, you may have complex enough types to describe that you choose to namespace them inside your .d.ts: ts// This represents the JavaScript class which would be available at runtimeexport class API { constructor(baseURL: string); getInfo(opts: API.InfoRequest): API.InfoResponse;}// This namespace is merged with the API class and allows for consumers, and this file// to have types which are nested away in their own sections.declare namespace API { export interface InfoRequest { id: string; } export interface InfoResponse { width: number; height: number; }} To understand how namespaces work in .d.ts files read the .d.ts deep dive. Optional Global Usage You can use export as namespace to declare that your module will be available in the global scope in UMD contexts: tsexport as namespace moduleName; Reference Example To give you an idea of how all these pieces can come together, here is a reference .d.ts to start with when making a new module ts// Type definitions for [~THE LIBRARY NAME~] [~OPTIONAL VERSION NUMBER~]// Project: [~THE PROJECT NAME~]// Definitions by: [~YOUR NAME~] <[~A URL FOR YOU~]>/*~ This is the module template file. You should rename it to index.d.ts *~ and place it in a folder with the same name as the module. *~ For example, if you were writing a file for "super-greeter", this *~ file should be 'super-greeter/index.d.ts' *//*~ If this module is a UMD module that exposes a global variable 'myLib' when *~ loaded outside a module loader environment, declare that global here. *~ Otherwise, delete this declaration. */export as namespace myLib;/*~ If this module exports functions, declare them like so. */export function myFunction(a: string): string;export function myOtherFunction(a: number): number;/*~ You can declare types that are available via importing the module */export interface SomeType { name: string; length: number; extras?: string[];}/*~ You can declare properties of the module using const, let, or var */export const myField: number; Library file layout The layout of your declaration files should mirror the layout of the library. A library can consist of multiple modules, such as myLib +---- index.js +---- foo.js +---- bar +---- index.js +---- baz.js These could be imported as jsvar a = require("myLib");var b = require("myLib/foo");var c = require("myLib/bar");var d = require("myLib/bar/baz"); Your declaration files should thus be @types/myLib +---- index.d.ts +---- foo.d.ts +---- bar +---- index.d.ts +---- baz.d.ts Testing your types If you are planning on submitting these changes to DefinitelyTyped for everyone to also use, then we recommend you: Create a new folder in node_modules/@types/[libname] Create an index.d.ts in that folder, and copy the example in See where your usage of the module breaks, and start to fill out the index.d.ts When you’re happy, clone DefinitelyTyped/DefinitelyTyped and follow the instructions in the README. Otherwise Create a new file in the root of your source tree: [libname].d.ts Add declare module "[libname]" { } Add the template inside the braces of the declare module, and see where your usage breaks On this pageComparing JavaScript to an example DTSCommon CommonJS PatternsDefault ExportsHandling Many Consuming ImportTypes in ModulesNamespaces in Module CodeOptional Global UsageReference ExampleLibrary file layoutTesting your typesIs this page helpful? Yes NoCustomizeSite Colours:SystemAlways LightAlways DarkCode Font:CascadiaCascadia (ligatures)ConsolasDank MonoFira CodeJetBrains MonoOpenDyslexicSF MonoSource Code ProMade with ♥ in Redmond, Boston, SF & Dublin© 2012-2025 MicrosoftPrivacyTerms of UseUsing TypeScriptGet StartedDownloadCommunityPlaygroundTSConfig RefCode SamplesWhy TypeScriptDesignCommunityGet HelpBlogGitHub RepoCommunity Chat@TypeScriptMastodonStack OverflowWeb Repo