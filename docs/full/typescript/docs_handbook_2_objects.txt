In JavaScript, the fundamental way that we group and pass around data is through objects. In TypeScript, we represent those through object types. As we’ve seen, they can be anonymous: tsfunction greet(person: { name: string; age: number }) { return "Hello " + person.name;}Try or they can be named by using either an interface: tsinterface Person { name: string; age: number;} function greet(person: Person) { return "Hello " + person.name;}Try or a type alias: tstype Person = { name: string; age: number;}; function greet(person: Person) { return "Hello " + person.name;}Try In all three examples above, we’ve written functions that take objects that contain the property name (which must be a string) and age (which must be a number). Quick Reference We have cheat-sheets available for both type and interface, if you want a quick look at the important every-day syntax at a glance. Property Modifiers Each property in an object type can specify a couple of things: the type, whether the property is optional, and whether the property can be written to. Optional Properties Much of the time, we’ll find ourselves dealing with objects that might have a property set. In those cases, we can mark those properties as optional by adding a question mark (?) to the end of their names. tsinterface PaintOptions { shape: Shape; xPos?: number; yPos?: number;} function paintShape(opts: PaintOptions) { // ...} const shape = getShape();paintShape({ shape });paintShape({ shape, xPos: 100 });paintShape({ shape, yPos: 100 });paintShape({ shape, xPos: 100, yPos: 100 });Try In this example, both xPos and yPos are considered optional. We can choose to provide either of them, so every call above to paintShape is valid. All optionality really says is that if the property is set, it better have a specific type. We can also read from those properties - but when we do under strictNullChecks, TypeScript will tell us they’re potentially undefined. tsfunction paintShape(opts: PaintOptions) { let xPos = opts.xPos; (property) PaintOptions.xPos?: number | undefined let yPos = opts.yPos; (property) PaintOptions.yPos?: number | undefined // ...}Try In JavaScript, even if the property has never been set, we can still access it - it’s just going to give us the value undefined. We can just handle undefined specially by checking for it. tsfunction paintShape(opts: PaintOptions) { let xPos = opts.xPos === undefined ? 0 : opts.xPos; let xPos: number let yPos = opts.yPos === undefined ? 0 : opts.yPos; let yPos: number // ...}Try Note that this pattern of setting defaults for unspecified values is so common that JavaScript has syntax to support it. tsfunction paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) { console.log("x coordinate at", xPos); (parameter) xPos: number console.log("y coordinate at", yPos); (parameter) yPos: number // ...}Try Here we used a destructuring pattern for paintShape’s parameter, and provided default values for xPos and yPos. Now xPos and yPos are both definitely present within the body of paintShape, but optional for any callers to paintShape. Note that there is currently no way to place type annotations within destructuring patterns. This is because the following syntax already means something different in JavaScript. tsfunction draw({ shape: Shape, xPos: number = 100 /*...*/ }) { render(shape);Cannot find name 'shape'. Did you mean 'Shape'?2552Cannot find name 'shape'. Did you mean 'Shape'? render(xPos);Cannot find name 'xPos'.2304Cannot find name 'xPos'.}Try In an object destructuring pattern, shape: Shape means “grab the property shape and redefine it locally as a variable named Shape.” Likewise xPos: number creates a variable named number whose value is based on the parameter’s xPos. readonly Properties Properties can also be marked as readonly for TypeScript. While it won’t change any behavior at runtime, a property marked as readonly can’t be written to during type-checking. tsinterface SomeType { readonly prop: string;} function doSomething(obj: SomeType) { // We can read from 'obj.prop'. console.log(`prop has the value '${obj.prop}'.`); // But we can't re-assign it. obj.prop = "hello";Cannot assign to 'prop' because it is a read-only property.2540Cannot assign to 'prop' because it is a read-only property.}Try Using the readonly modifier doesn’t necessarily imply that a value is totally immutable - or in other words, that its internal contents can’t be changed. It just means the property itself can’t be re-written to. tsinterface Home { readonly resident: { name: string; age: number };} function visitForBirthday(home: Home) { // We can read and update properties from 'home.resident'. console.log(`Happy birthday ${home.resident.name}!`); home.resident.age++;} function evict(home: Home) { // But we can't write to the 'resident' property itself on a 'Home'. home.resident = {Cannot assign to 'resident' because it is a read-only property.2540Cannot assign to 'resident' because it is a read-only property. name: "Victor the Evictor", age: 42, };}Try It’s important to manage expectations of what readonly implies. It’s useful to signal intent during development time for TypeScript on how an object should be used. TypeScript doesn’t factor in whether properties on two types are readonly when checking whether those types are compatible, so readonly properties can also change via aliasing. tsinterface Person { name: string; age: number;} interface ReadonlyPerson { readonly name: string; readonly age: number;} let writablePerson: Person = { name: "Person McPersonface", age: 42,}; // workslet readonlyPerson: ReadonlyPerson = writablePerson; console.log(readonlyPerson.age); // prints '42'writablePerson.age++;console.log(readonlyPerson.age); // prints '43'Try Using mapping modifiers, you can remove readonly attributes. Index Signatures Sometimes you don’t know all the names of a type’s properties ahead of time, but you do know the shape of the values. In those cases you can use an index signature to describe the types of possible values, for example: tsinterface StringArray { [index: number]: string;} const myArray: StringArray = getStringArray();const secondItem = myArray[1]; const secondItem: stringTry Above, we have a StringArray interface which has an index signature. This index signature states that when a StringArray is indexed with a number, it will return a string. Only some types are allowed for index signature properties: string, number, symbol, template string patterns, and union types consisting only of these. It is possible to support multiple types of indexers... It is possible to support multiple types of indexers. Note that when using both `number` and `string` indexers, the type returned from a numeric indexer must be a subtype of the type returned from the string indexer. This is because when indexing with a number, JavaScript will actually convert that to a string before indexing into an object. That means that indexing with 100 (a number) is the same thing as indexing with "100" (a string), so the two need to be consistent. tsinterface Animal { name: string;} interface Dog extends Animal { breed: string;} // Error: indexing with a numeric string might get you a completely separate type of Animal!interface NotOkay { [x: number]: Animal;'number' index type 'Animal' is not assignable to 'string' index type 'Dog'.2413'number' index type 'Animal' is not assignable to 'string' index type 'Dog'. [x: string]: Dog;}Try While string index signatures are a powerful way to describe the “dictionary” pattern, they also enforce that all properties match their return type. This is because a string index declares that obj.property is also available as obj["property"]. In the following example, name’s type does not match the string index’s type, and the type checker gives an error: tsinterface NumberDictionary { [index: string]: number; length: number; // ok name: string;Property 'name' of type 'string' is not assignable to 'string' index type 'number'.2411Property 'name' of type 'string' is not assignable to 'string' index type 'number'.}Try However, properties of different types are acceptable if the index signature is a union of the property types: tsinterface NumberOrStringDictionary { [index: string]: number | string; length: number; // ok, length is a number name: string; // ok, name is a string}Try Finally, you can make index signatures readonly in order to prevent assignment to their indices: tsinterface ReadonlyStringArray { readonly [index: number]: string;} let myArray: ReadonlyStringArray = getReadOnlyStringArray();myArray[2] = "Mallory";Index signature in type 'ReadonlyStringArray' only permits reading.2542Index signature in type 'ReadonlyStringArray' only permits reading.Try You can’t set myArray[2] because the index signature is readonly. Excess Property Checks Where and how an object is assigned a type can make a difference in the type system. One of the key examples of this is in excess property checking, which validates the object more thoroughly when it is created and assigned to an object type during creation. tsinterface SquareConfig { color?: string; width?: number;} function createSquare(config: SquareConfig): { color: string; area: number } { return { color: config.color || "red", area: config.width ? config.width * config.width : 20, };} let mySquare = createSquare({ colour: "red", width: 100 });Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?Try Notice the given argument to createSquare is spelled colour instead of color. In plain JavaScript, this sort of thing fails silently. You could argue that this program is correctly typed, since the width properties are compatible, there’s no color property present, and the extra colour property is insignificant. However, TypeScript takes the stance that there’s probably a bug in this code. Object literals get special treatment and undergo excess property checking when assigning them to other variables, or passing them as arguments. If an object literal has any properties that the “target type” doesn’t have, you’ll get an error: tslet mySquare = createSquare({ colour: "red", width: 100 });Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?2561Object literal may only specify known properties, but 'colour' does not exist in type 'SquareConfig'. Did you mean to write 'color'?Try Getting around these checks is actually really simple. The easiest method is to just use a type assertion: tslet mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);Try However, a better approach might be to add a string index signature if you’re sure that the object can have some extra properties that are used in some special way. If SquareConfig can have color and width properties with the above types, but could also have any number of other properties, then we could define it like so: tsinterface SquareConfig { color?: string; width?: number; [propName: string]: unknown;}Try Here we’re saying that SquareConfig can have any number of properties, and as long as they aren’t color or width, their types don’t matter. One final way to get around these checks, which might be a bit surprising, is to assign the object to another variable: Since assigning squareOptions won’t undergo excess property checks, the compiler won’t give you an error: tslet squareOptions = { colour: "red", width: 100 };let mySquare = createSquare(squareOptions);Try The above workaround will work as long as you have a common property between squareOptions and SquareConfig. In this example, it was the property width. It will however, fail if the variable does not have any common object property. For example: tslet squareOptions = { colour: "red" };let mySquare = createSquare(squareOptions);Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.2559Type '{ colour: string; }' has no properties in common with type 'SquareConfig'.Try Keep in mind that for simple code like above, you probably shouldn’t be trying to “get around” these checks. For more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs. That means if you’re running into excess property checking problems for something like option bags, you might need to revise some of your type declarations. In this instance, if it’s okay to pass an object with both a color or colour property to createSquare, you should fix up the definition of SquareConfig to reflect that. Extending Types It’s pretty common to have types that might be more specific versions of other types. For example, we might have a BasicAddress type that describes the fields necessary for sending letters and packages in the U.S. tsinterface BasicAddress { name?: string; street: string; city: string; country: string; postalCode: string;}Try In some situations that’s enough, but addresses often have a unit number associated with them if the building at an address has multiple units. We can then describe an AddressWithUnit. tsinterface AddressWithUnit { name?: string; unit: string; street: string; city: string; country: string; postalCode: string;}Try This does the job, but the downside here is that we had to repeat all the other fields from BasicAddress when our changes were purely additive. Instead, we can extend the original BasicAddress type and just add the new fields that are unique to AddressWithUnit. tsinterface BasicAddress { name?: string; street: string; city: string; country: string; postalCode: string;} interface AddressWithUnit extends BasicAddress { unit: string;}Try The extends keyword on an interface allows us to effectively copy members from other named types, and add whatever new members we want. This can be useful for cutting down the amount of type declaration boilerplate we have to write, and for signaling intent that several different declarations of the same property might be related. For example, AddressWithUnit didn’t need to repeat the street property, and because street originates from BasicAddress, a reader will know that those two types are related in some way. interfaces can also extend from multiple types. tsinterface Colorful { color: string;} interface Circle { radius: number;} interface ColorfulCircle extends Colorful, Circle {} const cc: ColorfulCircle = { color: "red", radius: 42,};Try Intersection Types interfaces allowed us to build up new types from other types by extending them. TypeScript provides another construct called intersection types that is mainly used to combine existing object types. An intersection type is defined using the & operator. tsinterface Colorful { color: string;}interface Circle { radius: number;} type ColorfulCircle = Colorful & Circle;Try Here, we’ve intersected Colorful and Circle to produce a new type that has all the members of Colorful and Circle. tsfunction draw(circle: Colorful & Circle) { console.log(`Color was ${circle.color}`); console.log(`Radius was ${circle.radius}`);} // okaydraw({ color: "blue", radius: 42 }); // oopsdraw({ color: "red", raidus: 42 });Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?2561Object literal may only specify known properties, but 'raidus' does not exist in type 'Colorful & Circle'. Did you mean to write 'radius'?Try Interface Extension vs. Intersection We just looked at two ways to combine types which are similar, but are actually subtly different. With interfaces, we could use an extends clause to extend from other types, and we were able to do something similar with intersections and name the result with a type alias. The principal difference between the two is how conflicts are handled, and that difference is typically one of the main reasons why you’d pick one over the other between an interface and a type alias of an intersection type. If interfaces are defined with the same name, TypeScript will attempt to merge them if the properties are compatible. If the properties are not compatible (i.e., they have the same property name but different types), TypeScript will raise an error. In the case of intersection types, properties with different types will be merged automatically. When the type is used later, TypeScript will expect the property to satisfy both types simultaneously, which may produce unexpected results. For example, the following code will throw an error because the properties are incompatible: tsinterface Person { name: string;}interface Person { name: number;} In contrast, the following code will compile, but it results in a never type: tsinterface Person1 { name: string;} interface Person2 { name: number;} type Staff = Person1 & Person2 declare const staffer: Staff;staffer.name; (property) name: neverTry In this case, Staff would require the name property to be both a string and a number, which results in property being of type never. Generic Object Types Let’s imagine a Box type that can contain any value - strings, numbers, Giraffes, whatever. tsinterface Box { contents: any;}Try Right now, the contents property is typed as any, which works, but can lead to accidents down the line. We could instead use unknown, but that would mean that in cases where we already know the type of contents, we’d need to do precautionary checks, or use error-prone type assertions. tsinterface Box { contents: unknown;} let x: Box = { contents: "hello world",}; // we could check 'x.contents'if (typeof x.contents === "string") { console.log(x.contents.toLowerCase());} // or we could use a type assertionconsole.log((x.contents as string).toLowerCase());Try One type safe approach would be to instead scaffold out different Box types for every type of contents. tsinterface NumberBox { contents: number;} interface StringBox { contents: string;} interface BooleanBox { contents: boolean;}Try But that means we’ll have to create different functions, or overloads of functions, to operate on these types. tsfunction setContents(box: StringBox, newContents: string): void;function setContents(box: NumberBox, newContents: number): void;function setContents(box: BooleanBox, newContents: boolean): void;function setContents(box: { contents: any }, newContents: any) { box.contents = newContents;}Try That’s a lot of boilerplate. Moreover, we might later need to introduce new types and overloads. This is frustrating, since our box types and overloads are all effectively the same. Instead, we can make a generic Box type which declares a type parameter. tsinterface Box<Type> { contents: Type;}Try You might read this as “A Box of Type is something whose contents have type Type”. Later on, when we refer to Box, we have to give a type argument in place of Type. tslet box: Box<string>;Try Think of Box as a template for a real type, where Type is a placeholder that will get replaced with some other type. When TypeScript sees Box<string>, it will replace every instance of Type in Box<Type> with string, and end up working with something like { contents: string }. In other words, Box<string> and our earlier StringBox work identically. tsinterface Box<Type> { contents: Type;}interface StringBox { contents: string;} let boxA: Box<string> = { contents: "hello" };boxA.contents; (property) Box<string>.contents: string let boxB: StringBox = { contents: "world" };boxB.contents; (property) StringBox.contents: stringTry Box is reusable in that Type can be substituted with anything. That means that when we need a box for a new type, we don’t need to declare a new Box type at all (though we certainly could if we wanted to). tsinterface Box<Type> { contents: Type;} interface Apple { // ....} // Same as '{ contents: Apple }'.type AppleBox = Box<Apple>;Try This also means that we can avoid overloads entirely by instead using generic functions. tsfunction setContents<Type>(box: Box<Type>, newContents: Type) { box.contents = newContents;}Try It is worth noting that type aliases can also be generic. We could have defined our new Box<Type> interface, which was: tsinterface Box<Type> { contents: Type;}Try by using a type alias instead: tstype Box<Type> = { contents: Type;};Try Since type aliases, unlike interfaces, can describe more than just object types, we can also use them to write other kinds of generic helper types. tstype OrNull<Type> = Type | null; type OneOrMany<Type> = Type | Type[]; type OneOrManyOrNull<Type> = OrNull<OneOrMany<Type>>; type OneOrManyOrNull<Type> = OneOrMany<Type> | null type OneOrManyOrNullStrings = OneOrManyOrNull<string>; type OneOrManyOrNullStrings = OneOrMany<string> | nullTry We’ll circle back to type aliases in just a little bit. The Array Type Generic object types are often some sort of container type that work independently of the type of elements they contain. It’s ideal for data structures to work this way so that they’re re-usable across different data types. It turns out we’ve been working with a type just like that throughout this handbook: the Array type. Whenever we write out types like number[] or string[], that’s really just a shorthand for Array<number> and Array<string>. tsfunction doSomething(value: Array<string>) { // ...} let myArray: string[] = ["hello", "world"]; // either of these work!doSomething(myArray);doSomething(new Array("hello", "world"));Try Much like the Box type above, Array itself is a generic type. tsinterface Array<Type> { /** * Gets or sets the length of the array. */ length: number; /** * Removes the last element from an array and returns it. */ pop(): Type | undefined; /** * Appends new elements to an array, and returns the new length of the array. */ push(...items: Type[]): number; // ...}Try Modern JavaScript also provides other data structures which are generic, like Map<K, V>, Set<T>, and Promise<T>. All this really means is that because of how Map, Set, and Promise behave, they can work with any sets of types. The ReadonlyArray Type The ReadonlyArray is a special type that describes arrays that shouldn’t be changed. tsfunction doStuff(values: ReadonlyArray<string>) { // We can read from 'values'... const copy = values.slice(); console.log(`The first value is ${values[0]}`); // ...but we can't mutate 'values'. values.push("hello!");Property 'push' does not exist on type 'readonly string[]'.2339Property 'push' does not exist on type 'readonly string[]'.}Try Much like the readonly modifier for properties, it’s mainly a tool we can use for intent. When we see a function that returns ReadonlyArrays, it tells us we’re not meant to change the contents at all, and when we see a function that consumes ReadonlyArrays, it tells us that we can pass any array into that function without worrying that it will change its contents. Unlike Array, there isn’t a ReadonlyArray constructor that we can use. tsnew ReadonlyArray("red", "green", "blue");'ReadonlyArray' only refers to a type, but is being used as a value here.2693'ReadonlyArray' only refers to a type, but is being used as a value here.Try Instead, we can assign regular Arrays to ReadonlyArrays. tsconst roArray: ReadonlyArray<string> = ["red", "green", "blue"];Try Just as TypeScript provides a shorthand syntax for Array<Type> with Type[], it also provides a shorthand syntax for ReadonlyArray<Type> with readonly Type[]. tsfunction doStuff(values: readonly string[]) { // We can read from 'values'... const copy = values.slice(); console.log(`The first value is ${values[0]}`); // ...but we can't mutate 'values'. values.push("hello!");Property 'push' does not exist on type 'readonly string[]'.2339Property 'push' does not exist on type 'readonly string[]'.}Try One last thing to note is that unlike the readonly property modifier, assignability isn’t bidirectional between regular Arrays and ReadonlyArrays. tslet x: readonly string[] = [];let y: string[] = []; x = y;y = x;The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.4104The type 'readonly string[]' is 'readonly' and cannot be assigned to the mutable type 'string[]'.Try Tuple Types A tuple type is another sort of Array type that knows exactly how many elements it contains, and exactly which types it contains at specific positions. tstype StringNumberPair = [string, number];Try Here, StringNumberPair is a tuple type of string and number. Like ReadonlyArray, it has no representation at runtime, but is significant to TypeScript. To the type system, StringNumberPair describes arrays whose 0 index contains a string and whose 1 index contains a number. tsfunction doSomething(pair: [string, number]) { const a = pair[0]; const a: string const b = pair[1]; const b: number // ...} doSomething(["hello", 42]);Try If we try to index past the number of elements, we’ll get an error. tsfunction doSomething(pair: [string, number]) { // ... const c = pair[2];Tuple type '[string, number]' of length '2' has no element at index '2'.2493Tuple type '[string, number]' of length '2' has no element at index '2'.}Try We can also destructure tuples using JavaScript’s array destructuring. tsfunction doSomething(stringHash: [string, number]) { const [inputString, hash] = stringHash; console.log(inputString); const inputString: string console.log(hash); const hash: number}Try Tuple types are useful in heavily convention-based APIs, where each element’s meaning is “obvious”. This gives us flexibility in whatever we want to name our variables when we destructure them. In the above example, we were able to name elements 0 and 1 to whatever we wanted. However, since not every user holds the same view of what’s obvious, it may be worth reconsidering whether using objects with descriptive property names may be better for your API. Other than those length checks, simple tuple types like these are equivalent to types which are versions of Arrays that declare properties for specific indexes, and that declare length with a numeric literal type. tsinterface StringNumberPair { // specialized properties length: 2; 0: string; 1: number; // Other 'Array<string | number>' members... slice(start?: number, end?: number): Array<string | number>;}Try Another thing you may be interested in is that tuples can have optional properties by writing out a question mark (? after an element’s type). Optional tuple elements can only come at the end, and also affect the type of length. tstype Either2dOr3d = [number, number, number?]; function setCoordinate(coord: Either2dOr3d) { const [x, y, z] = coord; const z: number | undefined console.log(`Provided coordinates had ${coord.length} dimensions`); (property) length: 2 | 3}Try Tuples can also have rest elements, which have to be an array/tuple type. tstype StringNumberBooleans = [string, number, ...boolean[]];type StringBooleansNumber = [string, ...boolean[], number];type BooleansStringNumber = [...boolean[], string, number];Try StringNumberBooleans describes a tuple whose first two elements are string and number respectively, but which may have any number of booleans following. StringBooleansNumber describes a tuple whose first element is string and then any number of booleans and ending with a number. BooleansStringNumber describes a tuple whose starting elements are any number of booleans and ending with a string then a number. A tuple with a rest element has no set “length” - it only has a set of well-known elements in different positions. tsconst a: StringNumberBooleans = ["hello", 1];const b: StringNumberBooleans = ["beautiful", 2, true];const c: StringNumberBooleans = ["world", 3, true, false, true, false, true];Try Why might optional and rest elements be useful? Well, it allows TypeScript to correspond tuples with parameter lists. Tuples types can be used in rest parameters and arguments, so that the following: tsfunction readButtonInput(...args: [string, number, ...boolean[]]) { const [name, version, ...input] = args; // ...}Try is basically equivalent to: tsfunction readButtonInput(name: string, version: number, ...input: boolean[]) { // ...}Try This is handy when you want to take a variable number of arguments with a rest parameter, and you need a minimum number of elements, but you don’t want to introduce intermediate variables. readonly Tuple Types One final note about tuple types - tuple types have readonly variants, and can be specified by sticking a readonly modifier in front of them - just like with array shorthand syntax. tsfunction doSomething(pair: readonly [string, number]) { // ...}Try As you might expect, writing to any property of a readonly tuple isn’t allowed in TypeScript. tsfunction doSomething(pair: readonly [string, number]) { pair[0] = "hello!";Cannot assign to '0' because it is a read-only property.2540Cannot assign to '0' because it is a read-only property.}Try Tuples tend to be created and left un-modified in most code, so annotating types as readonly tuples when possible is a good default. This is also important given that array literals with const assertions will be inferred with readonly tuple types. tslet point = [3, 4] as const; function distanceFromOrigin([x, y]: [number, number]) { return Math.sqrt(x ** 2 + y ** 2);} distanceFromOrigin(point);Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'. The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.2345Argument of type 'readonly [3, 4]' is not assignable to parameter of type '[number, number]'. The type 'readonly [3, 4]' is 'readonly' and cannot be assigned to the mutable type '[number, number]'.Try Here, distanceFromOrigin never modifies its elements, but expects a mutable tuple. Since point’s type was inferred as readonly [3, 4], it won’t be compatible with [number, number] since that type can’t guarantee point’s elements won’t be mutated. On this pageQuick ReferenceProperty ModifiersOptional Propertiesreadonly PropertiesIndex SignaturesExcess Property ChecksExtending TypesIntersection TypesInterface Extension vs. IntersectionGeneric Object TypesThe Array TypeThe ReadonlyArray TypeTuple Typesreadonly Tuple TypesIs this page helpful? Yes NoCustomizeSite Colours:SystemAlways LightAlways DarkCode Font:CascadiaCascadia (ligatures)ConsolasDank MonoFira CodeJetBrains MonoOpenDyslexicSF MonoSource Code ProMade with ♥ in Redmond, Boston, SF & Dublin© 2012-2025 MicrosoftPrivacyTerms of UseUsing TypeScriptGet StartedDownloadCommunityPlaygroundTSConfig RefCode SamplesWhy TypeScriptDesignCommunityGet HelpBlogGitHub RepoCommunity Chat@TypeScriptMastodonStack OverflowWeb Repo